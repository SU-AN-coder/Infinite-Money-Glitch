"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var kdf_exports = {};
__export(kdf_exports, {
  KeyPurpose: () => KeyPurpose,
  deriveKey: () => deriveKey,
  hashToG1: () => hashToG1,
  kdf: () => kdf
});
module.exports = __toCommonJS(kdf_exports);
var import_bcs = require("@mysten/bcs");
var import_sha3 = require("@noble/hashes/sha3");
var import_bls12381 = require("./bls12381.js");
var import_utils = require("./utils.js");
const DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-00");
const KDF_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H2-00");
const DERIVE_KEY_DST = new TextEncoder().encode("SUI-SEAL-IBE-BLS12381-H3-00");
function hashToG1(id) {
  return import_bls12381.G1Element.hashToCurve((0, import_utils.flatten)([DST, id]));
}
function kdf(element, nonce, id, objectId, index) {
  if (!Number.isInteger(index) || index < 0 || index > import_utils.MAX_U8) {
    throw new Error(`Invalid index ${index}`);
  }
  const objectIdBytes = (0, import_bcs.fromHex)(objectId);
  if (objectIdBytes.length !== import_utils.SUI_ADDRESS_LENGTH) {
    throw new Error(`Invalid object id ${objectId}`);
  }
  const hash = import_sha3.sha3_256.create();
  hash.update(KDF_DST);
  hash.update(element.toBytes());
  hash.update(nonce.toBytes());
  hash.update(hashToG1(id).toBytes());
  hash.update(objectIdBytes);
  hash.update(new Uint8Array([index]));
  return hash.digest();
}
var KeyPurpose = /* @__PURE__ */ ((KeyPurpose2) => {
  KeyPurpose2[KeyPurpose2["EncryptedRandomness"] = 0] = "EncryptedRandomness";
  KeyPurpose2[KeyPurpose2["DEM"] = 1] = "DEM";
  return KeyPurpose2;
})(KeyPurpose || {});
function tag(purpose) {
  switch (purpose) {
    case 0 /* EncryptedRandomness */:
      return new Uint8Array([0]);
    case 1 /* DEM */:
      return new Uint8Array([1]);
    default:
      throw new Error(`Invalid key purpose ${purpose}`);
  }
}
function deriveKey(purpose, baseKey, encryptedShares, threshold, keyServers) {
  if (!Number.isInteger(threshold) || threshold <= 0 || threshold > import_utils.MAX_U8) {
    throw new Error(`Invalid threshold ${threshold}`);
  }
  if (encryptedShares.length !== keyServers.length) {
    throw new Error(
      `Mismatched shares ${encryptedShares.length} and key servers ${keyServers.length}`
    );
  }
  const keyServerBytes = keyServers.map((keyServer) => (0, import_bcs.fromHex)(keyServer));
  if (keyServerBytes.some((keyServer) => keyServer.length !== import_utils.SUI_ADDRESS_LENGTH)) {
    throw new Error(`Invalid key servers ${keyServers}`);
  }
  if (encryptedShares.some((share) => share.length !== import_utils.ENCRYPTED_SHARE_LENGTH)) {
    throw new Error(`Invalid encrypted shares ${encryptedShares}`);
  }
  if (baseKey.length !== import_utils.KEY_LENGTH) {
    throw new Error(`Invalid base key ${baseKey}`);
  }
  const hash = import_sha3.sha3_256.create();
  hash.update(DERIVE_KEY_DST);
  hash.update(baseKey);
  hash.update(tag(purpose));
  hash.update(new Uint8Array([threshold]));
  encryptedShares.forEach((share) => hash.update(share));
  keyServerBytes.forEach((keyServer) => hash.update(keyServer));
  return hash.digest();
}
//# sourceMappingURL=kdf.js.map
